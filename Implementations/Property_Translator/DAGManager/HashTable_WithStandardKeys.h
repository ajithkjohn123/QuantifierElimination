#ifndef HASHTABLE_MANAGER_STDKEYS_H
#define HASHTABLE_MANAGER_STDKEYS_H
#include <iostream>
#include <string>
#include <vector>
#include <stdlib.h>
using namespace std;


//the hashtable manager has no way of comparing the values stored. It can compare only keys, since the keys are standard.
//The keys generated by the client must be unique....

typedef unsigned long long int index_type;

/**
 * Define some primes.
 * Primes are the heart of hash functions. Various hash functions use various primes from this list.
 *
 * IMPORTANT: Size of the hashtable MUST be a prime
 */
#define PRIME0 1201
#define PRIME1 9901
#define PRIME2 93719






/**
 * This class represents the Status of HashTable operations.
 * It provides public method success(), that should be used to check the status of a operation on HashTable.
 * It also provides GetValue() method which returns the Value associated with the result of operation. If the success() method returns a false, then the value contains invalid content.
 *
 * This class is outside the HashTable class in order to allow its instantiation by clients of hashtable.
 */

template <class Value>
class HTStatusValue
{
 private:
  Value value;
  bool isSuccess;
 public:
  bool success()
  {

    return this->isSuccess;
  }
  Value GetValue()
  {
    return this->value;
  }

  HTStatusValue ( bool status_to_update, Value v)
    {
      value = v;
      isSuccess = status_to_update;
    }
};









/*
 * This class depicts the whole hashtable
 *
 * The HashTable public API
 *
 * Create A HashTable:
 * HashTable <Key, Value> hashtable_object

 * Insertion:
 * HTStatusValue<Value> result = hashtable_insert(key, value);
 * Return Value:
 * On Success, result.success()=true; result.GetValue()=the value just inserted
 * On Failure, result.success()=false; result.GetValue()=an invalid value
 *
 *
 * Deletion:
 * HTStatusValue<Value> result = hashtable_delete(key);
 * On Success, result.success()=true; result.GetValue()=the deleted value associated with the key
 * On Failure, result.success()=false; result.GetValue()= an invalid value
 *
 *
 * Search:
 * HTStatusValue<Value> result = hashtable_search(Key key)
 * On Success, result.success()=true; result.GetValue()=the value associated with the key being searched
 * On Failure, result.success()=false; result.GetValue()=an invalid value
 */


template <class Key, class Value>
  class HashTable
{

 private:
  //Define necessary inner classes
  //These classes form components of the hashtable



  class HashTableNode_StdKeys
  {
  /**
   * The individual node of a hashtable. Each node stores key and value.
   * A linked list of HashTableNode_StdKeyss is used to resolve the hash collisions, therefore contains a pointer HashTableNode_StdKeys* next
   */
  private:
    Key key;
    Value value;        //The Value to store in the table
  public:
    HashTableNode_StdKeys *next; //use it to form linked list in case of collisions
    Key getKey()
    {
      return this->key;
    }
    Value getValue()
    {
      return this->value;
    }

    HashTableNode_StdKeys()
      {
      }
    HashTableNode_StdKeys (Value value_of_node, Key key_of_node)
      {
        this->value = value_of_node;
        this->key = key_of_node;
        next = NULL;
      }


    void printHashTableNode()
    {
      if(this == NULL)//This condition cannot be here, check from outside
        {

        }
      else
        {
          cout<<"Key : "<<key<<endl;
	  //          cout<<"Value :"<<value<<endl;
        }
    }

  };







  /**
   * The HashTableIndexNode is header node of individual liked list of HashTableNode_StdKeyss. Therefore it contains a pointer HashTableNode_StdKeys * next, that points to the list.
   * A array of HashTableIndexNodes (of length SIZE) forms the directory in the hashtable.
   */
  class HashTableIndexNode
  {
  public:
    HashTableNode_StdKeys *next;
    HashTableIndexNode()
      {
        next = NULL;
      }
  };






 private:

  static const int SIZE = PRIME2; //This is static in order to initialize it



  //In general, class attributes cannot be initialized!!!

  typedef HashTableNode_StdKeys hashTableNode;
  typedef HashTableIndexNode hashTableIndexNode;
  vector <hashTableIndexNode> Buckets;


  int keys_stored;     //This field contains the actual number of keys stored
  int num_collisions;  //Current count of the number of collisions over the entire hashtable
  int buckets_used;    //Number of buckets used. Different from number of keys stored.



  /**
   * Hash functions for standard key types.
   */
  int Hash(string string_to_hash)
  {
    /* needs three primes; hashtable size is prime2;
       prime0, prime1 are both < prime2 */

    const int prime0 = PRIME0; //Must be a prime
    const int prime1 = PRIME1; //Must be a prime
    const int prime2 = SIZE;   //Must be a prime


    int hashval = 0;
    int i=0;
    while (string_to_hash[i]) {
      char c = string_to_hash[i];
      hashval = (hashval*prime0 + c*prime1) % prime2;
      i++;
    }
    return hashval;
  }


  int Hash(int integer_to_hash)
  {
    /* needs just two primes; hashtable's SIZE is second prime */
    const int prime1 = PRIME1;
    const int prime2 = SIZE;
    int hashval = 0;
    while (integer_to_hash != 0) {
      int lastbit = integer_to_hash % 2;
      integer_to_hash = integer_to_hash/2;
      hashval = (hashval + lastbit*prime1) % prime2;
    }
    return hashval;


  }




  bool CompareKeys(string key1, string key2)
  {
    if(! key1.compare(key2))
      return true;
    return false;
  }
  bool CompareKeys(int key1, int key2)
  {
    return (key1 == key2);
  }



  //Public API of the hashtable
 public:


  /**
   * Constructor for the hashtable
   * The vector of buckets is initially empty. The vector is resized to SIZE to create SIZE number of buckets.
   *
   *
   *
   */
  HashTable()
    {
      keys_stored = 0;
      num_collisions = 0;
      buckets_used = 0;
      //cerr<<"Created the HashTable \n";

      hashTableIndexNode node;
      Buckets.resize(SIZE,node);
      //cout<<"HashTable size is "<<Buckets.size()<<endl;
    }


  int getMaximumSizeOfHashTable()
  {
    return SIZE;
  }

  float getLoadFactor()
  {
    return ((float)keys_stored/SIZE); //Load factor w.r.t. size

  }

  int getStoredKeysCount()
  {
    return keys_stored;
  }
  int getCountOfCollisions()
  {
    return num_collisions;
  }



 private:

  inline bool insertNodeInList(index_type index,Value value_to_insert, Key key)
    {
      hashTableIndexNode head=Buckets[index];

      if(head.next == NULL)
        {

          hashTableNode *node_to_insert = new hashTableNode (value_to_insert, key);
          node_to_insert->next = NULL;
          (Buckets[index]).next = node_to_insert;
          buckets_used +=1; //head.next=1 means this is new bucket
          return true;
        }
      else if(head.next != NULL)
        {
          num_collisions += 1;
          hashTableIndexNode head = Buckets[index]; //head cannot be null here
          hashTableNode *node = head.next;
          while(node->next != NULL)
            {
              node = node->next;
            }
          hashTableNode *node_to_insert = new hashTableNode (value_to_insert, key);
          node_to_insert->next = NULL;
          node->next = node_to_insert;

          return true;
        }
      return true;
    }


 public:




  HTStatusValue<Value> hashtable_insert(Key key, Value val)
    {
      HTStatusValue <Value> s = hashtable_search(key);
      if(s.success())
        {
          // a node with this key exists in the hashtable
          HTStatusValue <Value> result (false, s.GetValue());
          return result;
        }

      index_type index = Hash(key); //the hash functions always return 0<= Hash(key) <SIZE



      bool insert_result = insertNodeInList(index, val, key);
      if(insert_result==false)
        {
          Value Dummy_Val;
          HTStatusValue <Value> result (false, Dummy_Val);
          return result;
        }
      HTStatusValue <Value> result (true, val);
      keys_stored+=1;
      return result;
    }


  /**
   *The deletion of a value takes a reference to value. However, we cannot delete it directly. Need to search...
   *
   **/

  HTStatusValue<Value> hashtable_delete(Key key)
    {
      //REVIEW THIS CODE THOUROUGHLY
      index_type index = Hash(key);
      hashTableIndexNode head = Buckets[index];

      if(head.next == NULL)
        {
          Value DummyValue;
          HTStatusValue <Value> result(false, DummyValue);
          return result;
        }

      else
        {
          hashTableNode *node = head.next; //head cannot be null here
          hashTableNode *prev = NULL; //must specify the starting condition
          while(node!=NULL)
            {
              Key current_key = node->getKey();
              if(CompareKeys(current_key,key))
                {
                  HTStatusValue <Value> result(true, node->getValue());
		  hashTableNode *node_to_delete = node;
                  keys_stored-=1;
                  if(prev == NULL)
                    {
                      //first node in the list
                      (Buckets[index]).next = node->next;
		      node = node->next;
		      delete(node_to_delete);
                      buckets_used -=1; //We are releasing this bucket...
                      return result;
                    }
                  if(node->next==NULL)
                    {
                      //last node in the list
                      prev->next = node->next;
                      delete(node_to_delete);
                      num_collisions -= 1;
                      return result;
                    }
                  else
                    {
                      //middle node in the list
                      prev->next = node->next;
		      node = node->next;
                      delete(node_to_delete);
                      num_collisions -= 1;
                      return result;
                    }
                }
	      else
		{
		  if(prev==NULL)
		    prev = node;
		  else
		    prev = prev->next;
		  node = node->next;

		}

            }
        }
      Value DummyValue;
      HTStatusValue <Value> result(false, DummyValue);

      return result;
    }




  HTStatusValue<Value> hashtable_search(Key key)
    {

      index_type index = Hash(key);

      hashTableIndexNode head = Buckets[index];
      if(head.next == NULL)
        {

          Value Dummy_Val;
          HTStatusValue <Value> result (false, Dummy_Val);
          return result;
        }
      else
        {
          hashTableIndexNode head = Buckets[index]; //head cannot be null here
          hashTableNode *node = head.next;
          while(node != NULL)
            {
              Key current_key = (Key)(node->getKey());
              if(CompareKeys(current_key,key))
                {
                  HTStatusValue <Value> result (true, node->getValue());
                  return result;
                }
              node = node->next;
            }
          Value Dummy_Val;
          HTStatusValue <Value> result (false, Dummy_Val);
          return result;

        }
    }


  int countNumberOfBucketsUsed()
  {
    return buckets_used;
  }





  /**
   * This function prints the hashtable, but only when standard values are used. Not otherwise.
   *
   *
   */

  void printHashTableKeys()
  {

    cout<<"Printing the keys in the hashtable\n";
    //if somebody wants values as well, then he can 
    //1. hashtable_search(key)
    //2. print the value associated with key
    index_type index = 0;

    for(index =0;index<SIZE;index++)
      {
        hashTableIndexNode head = Buckets[index];
        hashTableNode *node = head.next;

        while(node != NULL)
          {

            cout<<"Location :"<<index<<" : ";
            node->printHashTableNode();
            node = node->next;

          }
      }

  }


};
#endif
